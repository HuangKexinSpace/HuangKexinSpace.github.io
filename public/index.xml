<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kexin&#39;s Blog</title>
    <link>https://example.com/</link>
    <description>Recent content on Kexin&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>© Athul</copyright>
    <lastBuildDate>Fri, 19 Dec 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://example.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>游戏开发日记（1） - 251219</title>
      <link>https://example.com/posts/dairy/251219/</link>
      <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://example.com/posts/dairy/251219/</guid>
      <description>简介 开发目的 通过这种新的创作方式进行思考、表达、沟通和疗愈。 学习游戏开发 锻炼项目管理能力 游戏类型 把自己的大致想法告诉GPT，G老师跟我说我这个游戏类型算是【章节式情感叙事冒险游戏】。&#xA;整体规划 预期体量和用时： 目前大致确定了游戏的章节数，每章会有一个主要的交互游戏，章节之间会穿插叙事、解谜等碎片式交互（？。定位算是非常小型的游戏。预计玩的时间大约2-3小时？目前还不能准确的估计。 开发用时，预计工作日每天三小时，周末无上限。目前尚未完全步入开发正轨所以也难以估计开发用时，希望是可以在过年之前完成。 各方面投入预估 剧情策划：真实事件的现成素材，但为了好玩，会进行剧情的改编和悬疑设置。（时间投入：中、低程度） 交互设计：主要是基于已有经历设计若干个主要的交互体验玩法，以及整个游戏的世界观、生存机制等。（时间投入：中等） 开发：目前能够想到的开发工作应该都可以借助AI完成，唯一觉得可能是难点的部分在于动画系统，确实没有太多接触，但视觉并不是这个游戏的重点，所以视觉方面尽可能保持极简。（时间投入：中等） 美术：这个是目前觉得比较头疼的，肯定大部分是让AI完成，但promptAI生成一整套连贯可用的美术素材，感觉应该比较费劲。（时间投入：中等） 音乐：纯练手之作，不涉及版权，所以音乐可以找自己喜欢的、契合的就好。（时间投入：低） 当前进度 策划： GDDV0.1完成 玩法机制 V0.1进行中 剧情与文本 V0.1进行中 开发 尚未开始 美术 尚未开始 音乐 尚未开始 近期代办 策划 产出玩法机制-V0.1 产出剧情与文本-V0.1 项目管理 确定整体的开发进度规划 美术 生成主要场景及人物的美术素材 </description>
    </item>
    <item>
      <title>Unity - World Space下设置UI中到字体大小</title>
      <link>https://example.com/posts/deployment_web/unityworldspace%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F/</link>
      <pubDate>Mon, 14 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://example.com/posts/deployment_web/unityworldspace%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F/</guid>
      <description>疑问🤔 Unity中，为什么canvas（world space）下的text，需要在Canvas scaler的范围内，调整Dynamic pixels Per Unit 到一定数值，才可以调整front size大小，否则调front size大小没有用？ 其中dynamic pixels per unit（DPPU） 和 reference pixels per unit（RPPU） 分别有什么作用和关系，我需要大致设置什么数值，有什么规律？ Q &amp;amp; A 在 World Space 模式下，Canvas 的 UI 元素（例如 Text）可能会出现你“调整 font size 没有效果”的情况，原因往往是 Canvas Scaler 中的设置未配合好，特别是 Dynamic Pixels Per Unit (DPPU) 的数值。 Dynamic Pixels Per Unit 是什么？ Dynamic Pixels Per Unit (DPPU)：控制 UI 元素的像素密度（即1单位世界空间 = 多少像素），它影响的是字体的实际视觉大小。 举例：如果设置为10，意味着1单位世界空间的长度对应10像素；如果设置为 100，对应的视觉细节就会更小。 ✅ 在 World Space Canvas 中，DPPU 是字体显示效果的核心控制参数！ Reference Pixels Per Unit 是什么？ Reference Pixels Per Unit (RPPU)：这是 基于 Canvas Scaler 的缩放参考值，控制 UI 在不同屏幕分辨率下的缩放行为。 主要作用在于 屏幕空间（Screen Space）Canvas，对于 World Space 的影响较小。 为什么调整 font size 没效果？ 在 World Space Canvas 中： 1.</description>
    </item>
    <item>
      <title>Dairy - 250330</title>
      <link>https://example.com/posts/dairy/250330/</link>
      <pubDate>Sun, 30 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://example.com/posts/dairy/250330/</guid>
      <description>深圳的温度骤降，在屋子里也感觉好冷。躲在宿舍，又撞上经期。感觉自己的生活从内而外地无法控制。&#xA;无法控制后腰持续不断的酸胀，无法控制一股一股血块从我体内排出。&#xA;无法振作萎靡的精神，也无法驱使躺在床上的身体干任何事情。&#xA;无法控制周一已经以势不可挡的节奏，冷酷、无情、不容商量余地地到来了。&#xA;无语。</description>
    </item>
    <item>
      <title>Dairy - 250325</title>
      <link>https://example.com/posts/dairy/250325/</link>
      <pubDate>Tue, 25 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://example.com/posts/dairy/250325/</guid>
      <description>知道想要的是什么 并为之去做 比什么都重要</description>
    </item>
    <item>
      <title>Dairy - 250323</title>
      <link>https://example.com/posts/dairy/250323/</link>
      <pubDate>Sun, 23 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://example.com/posts/dairy/250323/</guid>
      <description>很长一段时间，我对我的情绪失去信心，我觉得它再也不会变好了（至少在做完这个研究之前）。&#xA;但今天开完会之后，即使意识到存在很多问题，甚至这个研究很可能真的如我一直害怕的那般无法如期完成，那种焦虑的感觉好像也突然就消失了。&#xA;在去十楼搬电池的时候，我坐在光滑的水泥地上，没有开灯，心里想着如何好好享受我的周末夜晚。我发现我好像获得了很久很久都没有感受到的轻松。每时每刻都紧绷的神经似乎是真的放松下来了。&#xA;我很想知道但也不知道具体是什么原因。也许是在极度难受的前段时间，迫使自己每周末都要休息；强迫自己出门旅行；尝试找心理咨询；不想去工位就不去&amp;hellip;也许是上周觉察到自己的恐惧其实源于害怕项目难以完成而爆发的冲突，心理咨询师让我这周去探索如果项目真的完不成会怎样，我当时跟她讲说我绝不可能问老师这类问题，但这周老师竟然自己提到如果实在赶不上也没有关系的。&#xA;好像我心里的恐惧更多的来自于自己的想象和对外界的不信任，我很庆幸它是虚幻的，我也庆幸这个世界可能比我想象的要好。我也很庆幸，原来真的有峰回路转之时。&#xA;今天的讨论让我明白，这个项目一直以来我存在的问题，我觉得能够在研二下就意识到这个问题，其实也挺幸运的。&#xA;以及这个研究的结果无论是怎样的，我觉得我都能接受。进展再不顺利，我也不会过多地焦虑了，当然也不会因此而放弃。只要知道我每一周以及近期需要做的事情，这就很好了。我想我仍然会敏锐地察觉到别人的感受、评价，但我不会再在上面花费太多功夫和时间了。我觉得大家都有能力照顾好自己。&#xA;迟迟没有开始的申请计划，我总在等待一个恰好的时机。现在我明确地知道，我的申请计划会开始于2025年3月24日，不算太晚！&#xA;春天总会来的。 我期待着。</description>
    </item>
    <item>
      <title>Dairy - 250318</title>
      <link>https://example.com/posts/dairy/250318/</link>
      <pubDate>Tue, 18 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://example.com/posts/dairy/250318/</guid>
      <description>我需要控制自己的心情、情绪和情感。感觉一切都在下坠，但却无力挽回，不知道为什么会这样。对生活失去掌控感的感觉真的很糟糕。&#xA;我需要掌控自己的人生，筑起防御和保护的边界和屏障，不要为别人承担任何东西。&#xA;我要了解和理解自己真正想要的是什么，做自己想做的事。&#xA;我想我的许多不安都来自于我对这个世界的不信任。在一次次坍塌与崩裂的过程中，我一次次倒下，也会长出新的血肉吗。</description>
    </item>
    <item>
      <title>Dairy - 250315</title>
      <link>https://example.com/posts/dairy/250315/</link>
      <pubDate>Sat, 15 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://example.com/posts/dairy/250315/</guid>
      <description>飞行日记✈️ 飞机上 飞机还有15分钟降落上海浦东，今天深圳下了好大的雨，去年朋友来深圳和香港玩，也是三四月份，也是巨大的雨。我觉的生活在变好，不知道是因为它已经不能再糟糕了，还是自己的生命力能量在帮我逆转。一遍又一遍心理咨询，一根又一根烟，一分钟又一分钟煎熬。这一切都会过去的。&#xA;我觉得我最不能接受的，无非是自己亲手缔造一栋烂尾楼，更糟糕的是，这栋烂尾楼还投入了许多别的小伙伴的时间和心血。我不能接受这样的事情发生，我也几乎每时每刻都在担忧害怕着它的发生。但静下心来去看，添砖加瓦其实是一件非常有意义的事情，造楼的过程是值得的。&#xA;今夜一定是个美好的夜晚。&#xA;酒店 机场大巴到五角场只开了半个多小时。上海有一点小雨。在五角场万达逛了一会儿，然后跟朋友去吃了深夜食堂，很好吃！ 超好吃的三文鱼和粘粘的甜虾🦐 烧烤🍖 出来玩感觉整个心情都变好了许多，是以前从未体验到过的旅行的意义。之前出去玩，心里都还是想着未完成的研究。虽然现在也是，但也许是因为今天睡到了自然醒，还简单打扫了宿舍，然后还出来玩了，所以很开心。而且明天可以跟朋友一起学习一整天！🥳&#xA;感觉到自己对秩序的掌控越来越强&amp;hellip;</description>
    </item>
    <item>
      <title>Develop - hugo个人博客搭建</title>
      <link>https://example.com/posts/develop/blog/</link>
      <pubDate>Sat, 15 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://example.com/posts/develop/blog/</guid>
      <description>依赖项安装 Git Go: https://go.dev/doc/install Check if sucessful installed go version Dart Sass: brew install sass/sass/sass Check if sucessful installed hugo env 安装Hugo for mac 安装命令 brew install hugo check命令 hugo version 新建网站 安装一个主题的minimal command hugo new site quickstart cd quickstart git init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke echo &amp;#34;theme = &amp;#39;ananke&amp;#39;&amp;#34; &amp;gt;&amp;gt; hugo.toml hugo server 一步一步安装 在终端的自定义存放hugo的文件夹下运行 hugo new site your_folder_name cd your_folder_name git inti git submodule add your_choosed_theme_github_url echo &amp;#34;theme&amp;#34; = &amp;#39;theme_name&amp;#39;&amp;#34;&amp;gt;&amp;gt;hugo.</description>
    </item>
    <item>
      <title>Novobo （202310-202409）</title>
      <link>https://example.com/projects/novobo/</link>
      <pubDate>Sat, 15 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://example.com/projects/novobo/</guid>
      <description>项目介绍 利用大语言模型来支持教师教学手势方面的学习。具体来说，我们设计了一个新手教师小新（Novobo），老师们可以共同给小新一些具体的教学情景和教学语言，小新会根据其生成相应的手势描述，并给出她背后依据的教学手势理论，老师可以对小新的手势进行点评、并通过文字或动作教小新自己的理解。通过对手势的共同讨论和练习，教师之间的具身化知识得到表达和传递。&#xA;项目总结 这是我硕士阶段第一个完整参与的项目，也是跟师姐合作的第一个项目，学到了很多。基本的开发技能：用Python编写脚本并将其模块化；Openai的api调用；Prompt词的撰写技巧；git和conda的基本用法。基本的研究技能：设计开展用户实验、访谈；定性数据的分析：主题分析, vignetee analysis (视频的主题分析)；论文撰写。基本的设计技能：用Figma画线框图。&#xA;谢谢师姐，谢谢导师，谢谢论文的所有合作者和参与用户研究的所有老师们。我会一直记得，智园316的晚上，师姐的npy教我们如何从脚本构建模块；理学院圆桌上一次又一次的讨论；智园316晚上的线上会议，导师教我们什么才是系统设计；燥热的夏天，一间又一间的学校；9月的深夜与清晨，结束那夜的暴雨、商场和期盼了许久的椰子鸡。这一整年的收获，远比一个项目本身要多得多。&#xA;状态 - ✅定题 - ✅开发 - ✅实验 - ✅论文 - 🏃投稿 产出 系统开源代码：TBA </description>
    </item>
    <item>
      <title>Super Teacher （202410 - prsent）</title>
      <link>https://example.com/projects/superteacher/</link>
      <pubDate>Sat, 15 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://example.com/projects/superteacher/</guid>
      <description>状态 - 建设中 </description>
    </item>
    <item>
      <title>Develop - Notes for Writing Prompt</title>
      <link>https://example.com/posts/deployment_web/notes-for-writing-prompt/</link>
      <pubDate>Thu, 24 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://example.com/posts/deployment_web/notes-for-writing-prompt/</guid>
      <description>Reference: 我是如何赢得GPT-4提示工程大赛冠军的&#xA;使用CO-STAR框架搭建Prompt解构 context：与任务有关的背景信息 objective：LLM需要执行到任务 style：写作风格 tone：语气 audience：目标受众 response：响应的格式，理想格式应该是json 使用分隔符： “### content ###” “&amp;laquo;&amp;lt; content &amp;raquo;&amp;gt;” “&amp;lt; a &amp;gt; content &amp;lt; /a &amp;gt;” 使用LLM防护围栏创建系统提示：即利用不同区域的prompt LLM的数据分析 不擅长 相关性统计数值计算 相关性分析 统计分析 机器学习 擅长 异常检测 聚类 跨列关系 文本分析 趋势分析 </description>
    </item>
    <item>
      <title>Develop - Csharp &amp; Unity 扫盲</title>
      <link>https://example.com/posts/deployment_web/csharp--unity-%E6%89%AB%E7%9B%B2/</link>
      <pubDate>Fri, 11 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://example.com/posts/deployment_web/csharp--unity-%E6%89%AB%E7%9B%B2/</guid>
      <description>Reference: Code monkey C# Beginner Tutorial&#xA;QAs with GPT Q1: 这个c#脚本为啥没有实例化感觉就运行了？挂载到GameObject就是实例化了吗？向我解释C#的语法和逻辑。&#xA;A1: 在 Unity 中，C# 脚本的执行方式和一般的 C# 程序有所不同，这是因为 Unity 的运行环境和生命周期管理机制不一样。让我们详细看看为什么这个脚本在没有显式实例化的情况下依然可以运行，以及 Unity 的一些基础原理和 C# 的语法逻辑。 Unity 中脚本的工作原理&#xA;挂载到 GameObject： • 在 Unity 中，当你将一个脚本挂载到一个 GameObject 上时，Unity 会自动管理这个脚本的生命周期。相当于在场景中存在的 GameObject 成为了这个脚本类的一个实例化对象。 • 只要场景中存在这个 GameObject，Unity 就会根据生命周期事件（如 Start、Update、OnDestroy 等）自动调用相应的方法。 隐式实例化： • 当一个脚本被附加到一个 GameObject 时，Unity 实际上已经在内部为这个脚本类创建了一个实例，只是这个实例化过程是由 Unity 自动完成的，你不需要在代码中显式地调用 new 去创建对象。 • 所以你不需要像传统的 C# 程序那样使用 DoubleTabBackSceneCtrl myCtrl = new DoubleTabBackSceneCtrl();。Unity 在启动场景时会为你处理这些细节。 C# 脚本在 Unity 中的生命周期方法 Unity 使用 C# 脚本中的特殊方法来控制脚本的执行逻辑，这些方法根据特定的生命周期事件被自动调用： Start() 方法： • Start() 是 Unity 中的一个生命周期方法，当脚本实例在场景中启用时调用一次。它通常用于初始化状态或绑定事件监听器。将事件监听器添加到 Start() 中，确保了它是在游戏对象被启用时就已经准备好响应事件了。 • 当脚本被加载到 GameObject 上并且对象启用后，Unity 自动调用这个方法。 Update() 方法： • Update() 是 Unity 中最常用的一个方法，它在每一帧都被调用，用于持续检查和更新游戏状态。 • 任何需要频繁更新的逻辑，如角色的移动、物理计算等，通常都在这个方法中实现。 OnDestroy() 方法： • OnDestroy() 是当对象即将被销毁时调用的方法，用于执行清理操作，如取消事件订阅、释放资源等。 理解事件监听机制 在你的代码中，SimpleTouch.</description>
    </item>
    <item>
      <title>Develop - RayNeoX2_03_脚本功能描述-Slam,退出应用</title>
      <link>https://example.com/posts/deployment_web/rayneox2_03_%E8%84%9A%E6%9C%AC%E5%8A%9F%E8%83%BD%E6%8F%8F%E8%BF%B0/</link>
      <pubDate>Fri, 11 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://example.com/posts/deployment_web/rayneox2_03_%E8%84%9A%E6%9C%AC%E5%8A%9F%E8%83%BD%E6%8F%8F%E8%BF%B0/</guid>
      <description>Slam Demo 内置脚本描述 GameObject double Tab Back Scene Ctrl using RayNeo; using UnityEngine; using UnityEngine.InputSystem; using UnityEngine.SceneManagement; public class DoubleTabBackSceneCtrl : MonoBehaviour { //构造了一个方法，双击就退出到“Entry”场景 public void OnDoubleTapCallBack() { //加载”Entry“场景 SceneManager.LoadScene(&amp;#34;Entry&amp;#34;); } void Start() { //这句是为双击添加监听器，当触发双击后执行OnDoubleCallBAck这个函数 SimpleTouch.Instance.OnDoubleTap.AddListener(OnDoubleTapCallBack); } private void OnDestroy() { //移除监视器的常规操作 if (SimpleTouch.SingletonExist) { SimpleTouch.Instance.OnDoubleTap.RemoveListener(OnDoubleTapCallBack); } } } 功能：双击返回“Entry”场景 用法：挂载到空的GameObject上&#xA;SlamDemoCtrl 空Object 位置000 Slam Demo Ctrl using RayNeo.API; using UnityEngine; public class SlamDemoCtrl : MonoBehaviour { public GameObject m_Cube; public int m_LineCount = 10; public float m_CubeSpace = 0.</description>
    </item>
    <item>
      <title>Develop - RayNeoX2_01_环境配置</title>
      <link>https://example.com/posts/deployment_web/rayneox2_01_%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Wed, 09 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://example.com/posts/deployment_web/rayneox2_01_%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid>
      <description>官方文档 开发手册： 环境配置 参考教程： 官方文档 - OpenXR Unity ARDK - 最新 - 快速开始 - 开发环境搭建 （上述文档写的比较清晰，可以一步一步按照上述文档配，下面是我的配置记录） 安装Unity版本，安装时勾选 andriod build support，如果没勾选也可以安装后在设置的add mdules里再安装。 （推荐22.3.42f1或者2022.3.44f1 ，其他好几个版本都报错了） 创建3d core template 导入雷鸟sdk - 我选择安装包导入，也可以根据文档的从git中导入。 安装包链接（第二个） 导入成功后会提示重启，自动重启后如果控制台报错，再关掉unity再重启，如果还报错，大概率可能会是unity版本不兼容&amp;hellip;..如果不报错，就继续🏃‍♀️ 设置打包到安卓平台 点switch platform 环境配置 edit - project setting Player - other settings identification 勾选 重写包名 XR Plug- in Management - 安卓平台下 勾选OpenXR和RayNeo XR feature group 然后点击红色感叹号。 点击fix all Open XR - RayNeo Support 的设置 - 关掉ATW support 其他设置（必须） Project setting - player - publish setting -build -勾选custom main manifest 随后可在Unity&amp;gt;Project&amp;gt;Plugin&amp;gt;Android 文件夹下，找到自动生成的AndroidManifest.</description>
    </item>
    <item>
      <title>Develop - RayNeoX2_02_Demo初探、6dof</title>
      <link>https://example.com/posts/deployment_web/rayneox2_02_demo%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Wed, 09 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://example.com/posts/deployment_web/rayneox2_02_demo%E5%88%9D%E6%8E%A2/</guid>
      <description>Refer 官方文档 RayNeoX2_01_环境配置 构建第一个XR应用 Follow： 官方文档 - OpenXR Unity ARDK -最新 - 快速开始 - 构建第一个XR应用 添加XR Plugin 预制体 新建场景，最上方导航点Asstes - Create - Scene，新建的Scene（任何其他的东西）都会出现在Project的Assets文件夹中，然后我们把新建的这个New Scene拖到Hiearchy栏下。 在Unity中，Project下的Assets相当于仓库中的原料，把Assete中的东西从Project拖到Hierarchy上，就像是把原料摆到操作台上，而Scene/Game的视窗就是看看当前操作台上的东西长什么样子。 把New Scene中的Main Camera，Directional&#x9;light删除。 (然后就是一步一步跟着文档操作，我这里记录一些文档可能没有细节的步骤) 添加按钮和输入框 2. 配置Canvas 需要删除canvas下原有Graphic Raycaster,并添加我们的XRGraphicRaycaster 打包及投屏测试可以参考 RayNeoX2_01_环境配置 6dof功能 目前我的理解： Unity中必须要有相机，如果只是3D游戏，那么就用的是Unity内置的Camera。但XR设备总是有自己的摄像头的，因此它们通常需要自己的相机接口，所以每个XR设备的相机都不一样，我们需要看它们的官方文档，如何去调用相机。 而相机的视角和模式又与设计的需求息息相关，我们希望相机跟随人的头运动，还是固定视角？希望一个物体一直离我们保持一定的距离，还是我可以靠近它，走近它，这就需要看文档，去如何设置相机。 目前从“构建第一个XR应用”中发现，雷鸟的camera就是在XR Plugin中。 目前就是看Samples中的代码，看它6dof的实现代码。 </description>
    </item>
    <item>
      <title>Develop - Cpp - vector、迭代器</title>
      <link>https://example.com/posts/deployment_web/cpp1006---vector%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Sun, 06 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://example.com/posts/deployment_web/cpp1006---vector%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description> 范围for循环：处理字符串中的每个字符 for (declaration:expression) statement 下标运算符：s[0] 代表第一个字符 3.3 标准库类型vector From GPT：通俗地说，vector 是 C++ 中的动态数组，它可以自动调整大小，非常适合存储和管理一组数据。&#xA;加元素 push_back 若循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环。 3.4 迭代器 v.begin() 表示v的第一个元素，若v为空，则它是尾元素的下一位元素。 v.end() 表示v尾元素的下一位元素，即尾后迭代器。 迭代器类型：iterator 能读写元素 const_iterator 只能读不能写。 begin 和 end 运算符：若对象是常量，begin和end返回const_iterator; 若不是常量，返回iterator。 cbegin，cend 返回const_iterator。 -&amp;gt; 解引用+成员访问 </description>
    </item>
    <item>
      <title>Develop - Cpp - 标准库类型string</title>
      <link>https://example.com/posts/deployment_web/cpp1005---%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring/</link>
      <pubDate>Sat, 05 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://example.com/posts/deployment_web/cpp1005---%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring/</guid>
      <description>3.2 标准库类型string 读写string 对象 在进行读取cin操作时，string对象会自动忽略开头的空白（空格、换行 制表），从第一个真正的字符读起，直到遇到下一个空白停止。cin不进空格的。 保留空白符号：用getline。 //输入1，遇到空白停止 string in1; cin&amp;gt;&amp;gt;in1; cout&amp;lt;&amp;lt;in1&amp;lt;&amp;lt;endl; //输入2，遇到空白换行输出 string in2; while(cin&amp;gt;&amp;gt;in2) cout&amp;lt;&amp;lt;in2&amp;lt;&amp;lt;endl; //输入3，原样输出空白符 string in3; while(getline(cin,in3)) cout&amp;lt;&amp;lt;in3&amp;lt;&amp;lt;endl; </description>
    </item>
    <item>
      <title>Develop - Cpp - const限定符号、处理类型</title>
      <link>https://example.com/posts/deployment_web/cpp1004---const%E9%99%90%E5%AE%9A%E7%AC%A6%E5%8F%B7%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Fri, 04 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://example.com/posts/deployment_web/cpp1004---const%E9%99%90%E5%AE%9A%E7%AC%A6%E5%8F%B7%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B/</guid>
      <description>Cpp 2.4 const限定符 指针和const int errNumb = 0; int *const cuErr = &amp;amp;errNumb; //cuErr是一个指向int型对象的常量指针 它只指errNumb 不准变 const double pi = 3.14; const double *const pip = &amp;amp;pi;// pip是一个指向常量对象的常量指针 指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，需要看指向的对象是否可变。 顶层const 顶层const表示该对象本身是常量，底层const表示指针和引用所指的对象是常量。 constexpr和常量表达式 const int sz = get_size(); //sz不是常量表达式 尽管sz本身是一个常量，但它的具体值直到运行时才能获取，所以也不是常量表达式。&#xA;声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化，初始化了就不准变了，也不准重新赋值。 2.5 处理类型 类型别名 //两种起别名的方式 typedef double wages; using SI = Sales_item; 指针、常量和类型别名 不能直接替换来理解，而是要把别名的东西和修饰整体理解。这里有些抽象，遇到具体的再补充。 auto类型说明符 auto定义的变量必须要有初始值 复合类型、常量和auto auto一般回忽略顶层const，保留底层const decltype类型指示符 decltype的作用是选择并返回操作数的数据类型： decltype(f())sum = x; //sum的类型就是函数f的返回类型 2.6 自定义数据结构 </description>
    </item>
    <item>
      <title>Develop - Mac配置conda环境</title>
      <link>https://example.com/posts/deployment_web/mac%E9%85%8D%E7%BD%AEconda%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Fri, 04 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://example.com/posts/deployment_web/mac%E9%85%8D%E7%BD%AEconda%E7%8E%AF%E5%A2%83/</guid>
      <description>conda：类似于pip的包管理器，用于创建和管理虚拟环境，因为不同项目所需的包的版本不同，虚拟环境可以很好地区分和管理这些不同的包，类似于给每个项目划分出一个小房间，每个小房间可以放不同的工具。&#xA;conda 和venv的比较 • venv：Python 自带的轻量级虚拟环境管理工具。它只处理 Python 解释器及其依赖库，不支持管理其他语言或工具。venv 从 Python 3.3 开始内置，适合于单纯的 Python 项目。&#xA;• conda：一个更强大的包管理和环境管理工具，适用于多个编程语言（不仅限于 Python），可以管理 Python 版本、依赖库、其他编程语言（如 R）、以及外部工具（如 MKL、HDF5）。它不仅支持 Python，还支持其他科学计算库和工具，常见于 Anaconda 或 Miniconda 发行版。&#xA;环境配置 reference：YoutubeTutorial&#xA;在官网上freedownload mac版本，一路向前安装到底。 然后在终端用conda指令创建环境 然后在anacoanaconda中选择环境后，launch vscode （需要提前安装vscode）～就进入对应的环境啦。 conda 指令 创建：conda create —name xxx python=… 删除：conda remove -n EnvName - -all 进入：conda activate EnvName 退出：conda deactivate</description>
    </item>
    <item>
      <title>Develop - python基础语法 - long term</title>
      <link>https://example.com/posts/deployment_web/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Fri, 04 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://example.com/posts/deployment_web/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid>
      <description> 切片 # step是步长 左闭右开 list[start:end:step] for i in range (a,b) 左闭右开 升序排列函数 sorted(list, reverse = True) 取最小值 list = [1,2,3] min(1,2,3) min(list) 装饰器 和 静态方法 在 Python 中，@ 符号用于装饰器（decorators）。装饰器是一种特殊的函数，允许你在不改变原始函数代码的情况下，为函数、方法或类添加额外的功能。 @staticmethod 是 Python 中内置的一个装饰器，它表明该方法是一个静态方法（static method）。静态方法与普通方法不同，它不依赖于类的实例来调用。换句话说，静态方法不需要访问类的实例或类的属性，而是直接通过类本身调用。 静态方法常用于工具类（如 JSONUtils），当你需要将某些功能与类进行逻辑上的关联，但又不需要访问实例属性时，可以使用静态方法。 生成n✖️n的二维矩阵：matrix = [[0] * n for _ in range(n)] </description>
    </item>
    <item>
      <title>Develop - Cpp - 复合数据类型、const限定符</title>
      <link>https://example.com/posts/deployment_web/cpp1003---%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bconst%E9%99%90%E5%AE%9A%E7%AC%A6/</link>
      <pubDate>Thu, 03 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://example.com/posts/deployment_web/cpp1003---%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bconst%E9%99%90%E5%AE%9A%E7%AC%A6/</guid>
      <description>Cpp 2.3 复合数据类型 引用 引用就是起别名，引用的量必须先初始化。 一旦引用，引用值就和初始值绑定在一起，对其所有的操作都是在与之绑定的对象上（不能和字面值或者表达式的结果绑定）完成的。 引用不是对象，没有引用的引用。 引用的类型必须与它所引用的对象的类型严格匹配。（除了两个特殊情况） 引用代码example int ival = 6; int &amp;amp;renameival = ival; renameival = 999; std::cout&amp;lt;&amp;lt;ival&amp;lt;&amp;lt;std::endl; //输出会是999，所有的操作都是对ival完成的 指针 指针是一个对象，无需在定义时赋初值。因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。 除特殊情况外，指针的类型需要和其指向的对象严格匹配。 指针的状态： - 指向一个对象 - 指向紧邻对象所占空间的下一个位置（p++） - 空指针 - 无效指针，也就是除了上述情况的其他值 指针相等的三种可能：都为空/都指向同一个对象/都指向同一个对象的下一地址 void* 指针 void* 是一种特殊的指针类型，可用于存放任意对象的地址，不同的是我们对该地址中到底是个什么类型的对象并不了解。 void* 只能做：与别的指针比较、作为函数的输入或输出、或者赋值给另一个void* 指针。不能直接操作void 指针所指的对象，因为不知道它是啥类型的。* 要用的话必须进行显式的类型转换，转换为具体的类型指针后才能操作数据。 指针代码example // 定义空指针 int *p = nullptr; int i = 42; int *p= &amp;amp;i; std::cout&amp;lt;&amp;lt; *p &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; p &amp;lt;&amp;lt;std::endl; // void* 指针用法示例1：与别的指针比较 #include&amp;lt;iostream&amp;gt; int main(){ // std::cout&amp;lt;&amp;lt;&amp;#34;111&amp;#34;; // int v1; // std::cin&amp;gt;&amp;gt;v1; // std::cout&amp;lt;&amp;lt;v1&amp;lt;&amp;lt;std::endl; int i = 42; int j = 9; int *p= &amp;amp;i; void *q = &amp;amp;j; if (p == q){ std::cout&amp;lt;&amp;lt; &amp;#34;一样&amp;#34; &amp;lt;&amp;lt;std::endl; } else{ std::cout&amp;lt;&amp;lt; &amp;#34;不一样&amp;#34; &amp;lt;&amp;lt;std::endl; } return 0; } // void* 指针用法示例2：作为函数的输入或输出 #include &amp;lt;iostream&amp;gt; void printValue(void* data, char type) { // 根据类型来决定如何处理 void*，必须先进行强制类型转换 switch (type) { case &amp;#39;i&amp;#39;: // int 类型 std::cout &amp;lt;&amp;lt; &amp;#34;Integer: &amp;#34; &amp;lt;&amp;lt; *static_cast&amp;lt;int*&amp;gt;(data) &amp;lt;&amp;lt; std::endl; break; case &amp;#39;f&amp;#39;: // float 类型 std::cout &amp;lt;&amp;lt; &amp;#34;Float: &amp;#34; &amp;lt;&amp;lt; *static_cast&amp;lt;float*&amp;gt;(data) &amp;lt;&amp;lt; std::endl; break; case &amp;#39;c&amp;#39;: // char 类型 std::cout &amp;lt;&amp;lt; &amp;#34;Char: &amp;#34; &amp;lt;&amp;lt; *static_cast&amp;lt;char*&amp;gt;(data) &amp;lt;&amp;lt; std::endl; break; default: std::cout &amp;lt;&amp;lt; &amp;#34;Unknown type.</description>
    </item>
    <item>
      <title>Develop - Cpp - 类、变量</title>
      <link>https://example.com/posts/deployment_web/cpp0916/</link>
      <pubDate>Mon, 16 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://example.com/posts/deployment_web/cpp0916/</guid>
      <description>1.5 类 在头文件person.h中声明类 #ifndef PERSON_H // 防止头文件重复包含 #define PERSON_H #include &amp;lt;string&amp;gt; class Person { public: // 构造函数，参数列表包括名字和年龄 Person(const std::string&amp;amp; name, int age); // 获取名字 std::string getName() const; // 获取年龄 int getAge() const; // 设置名字 void setName(const std::string&amp;amp; name); // 设置年龄 void setAge(int age); private: std::string name; int age; }; #endif // PERSON_H 成员函数即定义在类/方法中的函数。 变量和基本类型 2.1 基本内置类型 2.1.1 算数类型 2.1.2 类型转换 2.1.3 字面值常量 2.2 变量 如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0，定义在函数体内部的内置类型变量将不被初始化，访问它会出现错误。 声明变量 extern int i; `</description>
    </item>
    <item>
      <title>About me</title>
      <link>https://example.com/about/</link>
      <pubDate>Tue, 27 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://example.com/about/</guid>
      <description>Me: I am a master&amp;rsquo;s student at SUSTech School of Design, majoring in Industrial Design Engineering. I am also a member of the ai{DEAL}Studio. My research field is human-computer interaction, and I am currently exploring the use of AI to support education and learning. EDUCATION September 2023 - Present: Master&amp;rsquo;s student in Industrial Design Engineering, Southern University of Science and Technology, Shenzhen September 2018 - June 2022: Undergraduate in Logistics Management, Nanjing University of Posts and Telecommunications, Nanjing RESEARCH A Super Teacher (202410 - Present)</description>
    </item>
    <item>
      <title>Develop - 为网站获取https协议</title>
      <link>https://example.com/posts/deployment_web/%E4%B8%BA%E7%BD%91%E7%AB%99%E8%8E%B7%E5%8F%96https%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Mon, 26 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://example.com/posts/deployment_web/%E4%B8%BA%E7%BD%91%E7%AB%99%E8%8E%B7%E5%8F%96https%E5%8D%8F%E8%AE%AE/</guid>
      <description>前言：买域名+解析+ssl证书部署+买服务器都是在腾讯云完成的。&#xA;购置域名 域名购买网址：https://buy.cloud.tencent.com/domain&#xA;域名解析 腾讯云控制台-我的域名：我的域名在域名栏的DNS状态，点击管理解析。或者也可以直接在腾讯云搜索DNS解析。 第一步点击后跳转到域名解析页面：https://console.cloud.tencent.com/cns/detail/teachernonverbal.asia/records&#xA;点击快速添加解析，如果有服务器的话就填主机IP，想要把网站部署到第三方托管平台的话，就点域名映射。如果在腾讯云买了服务器的话点腾讯云资源解析。还没想好/还没买好服务器的话就先点邮箱解析。 点确定后，大约过几分钟域名就会解析好。 ssl证书签发下载 在腾讯云搜索框搜索SSL，跳转到网址：https://console.cloud.tencent.com/ssl 点我的证书，然后点申请免费证书，根据指示填写。 填写完成几分钟后，站内信会提示SSL证书审核通过。这个时候回到我的证书页面，点击下载，选择Nginx。会下载下来一个压缩包，先放好。 服务器租赁 我选择了腾讯云的轻量应用服务器（便宜，需求不大），在腾讯云买服务器的网站上选轻量云服务器：https://cloud.tencent.com/product/lighthouse&#xA;选择应用模板的时候要选这个宝塔Linux面板，这个很大程度上会方便部署SSL证书。 后续操作：租赁好服务器后，在控制台中进入服务器页面，然后点域名解析。添加需要的域名。 后续操作：防火墙需要关闭，策略全部改为允许。添加规则，来源输入当前电脑常用网络的IP，端口写8888(我也不知道为何) SSL部署 按照这3个文档的顺序操作，非常丝滑：&#xA;https://cloud.tencent.com/document/product/213/5436&#xA;https://cloud.tencent.com/document/product/213/45550&#xA;https://cloud.tencent.com/document/product/400/50874（这个文档中的证书安装的1-2步即证书下载，上面步骤完成了。） 操作完成后，过几分钟，输入网址域名，就会看到https了。&#xA;备案 在腾讯云搜索备案，然后跟着要求操作就行了。</description>
    </item>
    <item>
      <title>Visibo （202412 - 202501）</title>
      <link>https://example.com/projects/visiobo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/projects/visiobo/</guid>
      <description>项目介绍 一个增强海报阅读的移动投影机器人。在公共场所的海报阅读往往是一个公开的、互动的过程，但由于海报本身的静态性、有限的容量和密集的排版，使得其阅读仍然存在种种局限。&#xA;我们设计了一个移动投影机器人来弥补以上局限，包含三个主要设计特质：&#xA;一个llm驱动的对话代理，跟用户就海报进行语音互动。 对所讨论的海报内容进行字符级别精度的视觉增强：箭头、高亮、闪烁标志等。 一个以概念图组织的扩展知识。 项目总结 跟师姐合作的第二个项目，谢谢师姐和导师，谢谢Z博和L同学，也谢谢所有参与实验的同学和老师们。这个项目并不在我的计划内，但却惊喜地成为了我的硕士阶段的第一个产出。Novobo给我的整体印象是”完整“，而Visiobo给我的整体印象则是“明确、快速”。师姐提出了一个初步的idea，在导师的指导下，我们很快就明确了要做什么。项目从开发、做实验到写论文，基本上就两个月左右的时间。在这个项目中，我再次训练了开发能力：包括LLM的搭建、前后端的联通以及检索和部署github上的开源项目；知道了用户实验的注意事项；写论文的能力也得到了很好的训练。&#xA;这次项目也有很多很多难忘的经历！例如第一次在纸上演算推出投影仪和海报之间的比例关系，第一次生成的高亮与文字精确地对齐（家人们谁懂啊那一刻🥹）。在3楼的小桌旁，导师跟我们一边讨论OCR，一边请我们吃砂糖桔桔🍊😈；在10楼的会议室里，导师一边帮我们分析用户实验的情况，一边吃光我们的小番茄🍅👿。在深夜的海底捞，第一次因为项目合作的问题跟师姐闹情绪，并崩溃大哭一小时🥹。最后阶段熬夜写论文的高压，提交后那晚的酒和电影。以及，最后两篇论文都中了的巨大喜悦。&#xA;这是一个非常非常有意思的项目，对我来说，也是一份非常幸运的礼物。&#xA;产出 开源代码：TBA 两篇会议短文：TBA </description>
    </item>
  </channel>
</rss>
